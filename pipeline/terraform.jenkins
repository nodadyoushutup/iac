pipeline {
  agent any

  options {
    ansiColor('xterm')
  }

  parameters {
    string(name: 'TFVARS_FILE', defaultValue: '', description: 'Optional tfvars path; leave empty to auto-discover defaults')
    string(name: 'BACKEND_FILE', defaultValue: '', description: 'Optional backend config path; leave empty to auto-discover defaults')
  }

  stages {
    stage('Terraform Version') {
      steps {
        sh 'terraform version'
      }
    }

    stage('Environment Check') {
      steps {
        script {
          def envOutput = sh(returnStdout: true, script: 'pipeline/scripts/env_check.sh').trim()
          def envData = parseAssignments(envOutput)

          env.PYTHON_CMD = envData.get('PYTHON_CMD') ?: ''
          env.FILTER_SCRIPT = envData.get('FILTER_SCRIPT') ?: ''
          env.FILTER_AVAILABLE = envData.get('FILTER_AVAILABLE') ?: '0'

          if ((env.PYTHON_CMD ?: '').trim()) {
            echo "Python command: ${env.PYTHON_CMD}"
          } else {
            echo 'python3 not found; Terraform warnings will be displayed'
          }

          if (env.FILTER_AVAILABLE == '1') {
            echo "Terraform output filter enabled (${env.PYTHON_CMD})"
          }
        }
      }
    }

    stage('Resolve Inputs') {
      steps {
        script {
          def tfvarsArg = params?.TFVARS_FILE ?: ''
          def backendArg = params?.BACKEND_FILE ?: ''

          def resolveCmd = "TFVARS_ARG=${shellEscape(tfvarsArg)} BACKEND_ARG=${shellEscape(backendArg)} pipeline/scripts/resolve_inputs.sh"
          def resolveOutput = sh(returnStdout: true, script: resolveCmd).trim()
          def inputs = parseAssignments(resolveOutput)

          env.TFVARS_PATH = requireValue(inputs, 'TFVARS_PATH')
          env.BACKEND_PATH = requireValue(inputs, 'BACKEND_PATH')

          echo "TFVARS file: ${env.TFVARS_PATH}"
          echo "Backend config: ${env.BACKEND_PATH}"
        }
      }
    }

    stage('Terraform Init') {
      steps {
        dir('terraform') {
          script {
            terraformExec(['init', '-backend-config', env.BACKEND_PATH])
          }
        }
      }
    }

    stage('App Plan') {
      steps {
        dir('terraform') {
          script {
            terraformExec([
              'plan',
              '-input=false',
              '-refresh=false',
              '-var-file',
              env.TFVARS_PATH,
              '-target=module.jenkins_app'
            ])
          }
        }
      }
    }

    stage('App Apply') {
      steps {
        dir('terraform') {
          script {
            terraformExec([
              'apply',
              '-input=false',
              '-refresh=false',
              '-auto-approve',
              '-var-file',
              env.TFVARS_PATH,
              '-target=module.jenkins_app'
            ])
          }
        }
      }
    }

    stage('Stabilize') {
      steps {
        sleep time: 10, unit: 'SECONDS'
      }
    }

    stage('Config Plan') {
      steps {
        dir('terraform') {
          script {
            terraformExec([
              'plan',
              '-input=false',
              '-var-file',
              env.TFVARS_PATH
            ])
          }
        }
      }
    }

    stage('Config Apply') {
      steps {
        dir('terraform') {
          script {
            terraformExec([
              'apply',
              '-input=false',
              '-auto-approve',
              '-var-file',
              env.TFVARS_PATH
            ])
          }
        }
      }
    }
  }
}

def terraformExec(List<String> args) {
  if (!args || args.isEmpty()) {
    error 'terraformExec requires at least one argument'
  }

  String exports = [
    "PYTHON_CMD=${shellEscape(env.PYTHON_CMD ?: '')}",
    "FILTER_SCRIPT=${shellEscape(env.FILTER_SCRIPT ?: '')}",
    "FILTER_AVAILABLE=${shellEscape(env.FILTER_AVAILABLE ?: '0')}"
  ].join(' ')

  String command = args.collect { shellEscape(it) }.join(' ')
  sh label: "terraform ${args[0]}", script: "${exports} pipeline/scripts/terraform_exec.sh ${command}"
}

def parseAssignments(String text) {
  def result = [:]
  def lines = text ? text.split("\\r?\\n") : []
  lines.each { line ->
    def trimmed = line.trim()
    if (!trimmed) {
      return
    }
    int idx = trimmed.indexOf('=')
    if (idx > 0) {
      String key = trimmed.substring(0, idx)
      String value = trimmed.substring(idx + 1)
      result[key] = value
    }
  }
  return result
}

def requireValue(Map data, String key) {
  if (!data.containsKey(key)) {
    error "Helper script did not provide ${key}"
  }
  def value = data[key]
  if (value == null || value.trim().isEmpty()) {
    error "Helper script returned empty ${key}"
  }
  return value
}

def shellEscape(String value) {
  if (value == null || value.isEmpty()) {
    return "''"
  }
  return "'" + value.replace("'", "'\\''") + "'"
}
