pipeline {
  agent alpha

  options {
    ansiColor('xterm')
  }

  parameters {
    string(name: 'TFVARS_FILE', defaultValue: '', description: 'Optional path to the tfvars file to use')
    string(name: 'BACKEND_FILE', defaultValue: '', description: 'Optional path to the backend config to use')
  }

  stages {
    stage('Verify Tooling') {
      steps {
        sh 'command -v terraform >/dev/null 2>&1'
        sh 'command -v realpath >/dev/null 2>&1'
        sh 'terraform version'
      }
    }

    stage('Resolve Inputs') {
      steps {
        script {
          def quote = { value ->
            "\"${value.replace('\\', '\\\\').replace('"', '\\"')}\""
          }

          def fileExists = { path ->
            sh(returnStatus: true, script: """#!/usr/bin/env bash
test -f ${quote(path)}
""") == 0
          }

          def realPath = { path ->
            sh(returnStdout: true, script: """#!/usr/bin/env bash
realpath ${quote(path)}
""").trim()
          }

          def resolveTfvars = {
            def candidates = []
            if (params?.TFVARS_FILE?.trim()) {
              candidates << [label: 'Provided TFVARS', path: params.TFVARS_FILE.trim(), warnMissing: true]
            }
            candidates << [label: 'Default TFVARS', path: "${env.HOME}/.tfvars/jenkins.tfvars", warnMissing: true]

            def workspace = pwd()
            def terraformDir = "${workspace}/terraform"
            def discovered = sh(returnStdout: true, script: """#!/usr/bin/env bash
find ${quote(terraformDir)} -maxdepth 1 -type f -name '*.tfvars' | sort | head -n 1 || true
""").trim()
            if (discovered) {
              candidates << [label: 'Workspace TFVARS', path: discovered, warnMissing: false]
            }

            for (candidate in candidates) {
              if (!candidate.path) {
                continue
              }
              if (fileExists(candidate.path)) {
                return realPath(candidate.path)
              }
              if (candidate.warnMissing) {
                echo "[WARN] ${candidate.label} not found at ${candidate.path}"
              }
            }

            error '[ERR] Unable to determine a usable TFVARS file'
          }

          def resolveBackend = {
            if (params?.BACKEND_FILE?.trim()) {
              def provided = params.BACKEND_FILE.trim()
              if (!fileExists(provided)) {
                error "[ERR] Provided backend config not found: ${provided}"
              }
              return realPath(provided)
            }

            def defaultPath = "${env.HOME}/.tfvars/minio.backend.hcl"
            if (fileExists(defaultPath)) {
              return realPath(defaultPath)
            }

            error '[ERR] Unable to determine a backend config file'
          }

          env.TFVARS_PATH = resolveTfvars()
          env.BACKEND_CONFIG_PATH = resolveBackend()
        }
      }
    }

    stage('Terraform Init') {
      steps {
        dir('terraform') {
          sh '''#!/usr/bin/env bash

[ -f "$TFVARS_PATH" ] || { echo "[ERR] Missing $TFVARS_PATH" >&2; exit 1; }
[ -f "$BACKEND_CONFIG_PATH" ] || { echo "[ERR] Missing $BACKEND_CONFIG_PATH" >&2; exit 1; }

echo "[STEP] terraform init"
terraform init -backend-config="$BACKEND_CONFIG_PATH"
'''
        }
      }
    }

    stage('App Plan & Apply') {
      steps {
        dir('terraform') {
          sh '''#!/usr/bin/env bash

echo "[STAGE] App plan"
terraform plan -input=false -refresh=false -var-file="$TFVARS_PATH" -target=module.jenkins_app

echo "[STAGE] App apply"
terraform apply -input=false -refresh=false -auto-approve -var-file="$TFVARS_PATH" -target=module.jenkins_app

sleep 10
'''
        }
      }
    }

    stage('Jenkins Config Plan & Apply') {
      steps {
        dir('terraform') {
          sh '''#!/usr/bin/env bash

echo "[STAGE] Jenkins config plan"
terraform plan -input=false -var-file="$TFVARS_PATH"

echo "[STAGE] Jenkins config apply"
terraform apply -input=false -auto-approve -var-file="$TFVARS_PATH"

echo "[DONE] Multi-stage apply complete."
'''
        }
      }
    }
  }
}
