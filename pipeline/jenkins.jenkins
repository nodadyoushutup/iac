pipeline {
  agent any

  options {
    ansiColor('xterm')
  }

  parameters {
    string(name: 'TFVARS_FILE', defaultValue: '', description: 'Optional tfvars path; leave empty to auto-discover defaults')
    string(name: 'BACKEND_FILE', defaultValue: '', description: 'Optional backend config path; leave empty to auto-discover defaults')
  }

  stages {
    stage('Terraform Version') {
      steps {
        sh 'terraform version'
      }
    }

    stage('Environment Check') {
      steps {
        script {
          def scriptRoot = env.WORKSPACE ? "${env.WORKSPACE}/pipeline/script" : 'pipeline/script'
          def envOutput = sh(returnStdout: true, script: shellEscape("${scriptRoot}/env_check.sh")).trim()
          def envData = parseAssignments(envOutput)

          env.PYTHON_CMD = envData.get('PYTHON_CMD') ?: ''
          env.FILTER_SCRIPT = envData.get('FILTER_SCRIPT') ?: ''
          env.FILTER_AVAILABLE = envData.get('FILTER_AVAILABLE') ?: '0'
          env.PIPELINE_SCRIPT_ROOT = envData.get('SCRIPT_ROOT') ?: scriptRoot

          if ((env.PYTHON_CMD ?: '').trim()) {
            echo "Python command: ${env.PYTHON_CMD}"
          } else {
            echo 'python3 not found; Terraform warnings will be displayed'
          }

          if (env.FILTER_AVAILABLE == '1') {
            echo "Terraform output filter enabled (${env.PYTHON_CMD})"
          }
        }
      }
    }

    stage('Resolve Inputs') {
      steps {
        script {
          def tfvarsArg = params?.TFVARS_FILE ?: ''
          def backendArg = params?.BACKEND_FILE ?: ''

          def scriptRoot = env.PIPELINE_SCRIPT_ROOT ?: (env.WORKSPACE ? "${env.WORKSPACE}/pipeline/script" : 'pipeline/script')
          def terraformDir = env.WORKSPACE ? "${env.WORKSPACE}/terraform/jenkins" : 'terraform/jenkins'
          def homeDir = env.HOME ?: ''

          def exports = [
            "TFVARS_ARG=${shellEscape(tfvarsArg)}",
            "BACKEND_ARG=${shellEscape(backendArg)}",
            "TERRAFORM_DIR=${shellEscape(terraformDir)}",
            "DEFAULT_TFVARS_BASENAME=${shellEscape('jenkins')}"
          ]

          if (homeDir?.trim()) {
            def tfvarsHome = "${homeDir}/.tfvars"
            exports += [
              "TFVARS_HOME_DIR=${shellEscape(tfvarsHome)}",
              "DEFAULT_TFVARS_FILE=${shellEscape("${tfvarsHome}/jenkins.tfvars")}",
              "DEFAULT_BACKEND_FILE=${shellEscape("${tfvarsHome}/minio.backend.hcl")}",
            ]
          }

          exports = exports.findAll { it && it.trim() }

          def resolveCmd = (exports + [shellEscape("${scriptRoot}/resolve_inputs.sh")]).join(' ').trim()
          def resolveOutput = sh(returnStdout: true, script: resolveCmd).trim()
          def inputs = parseAssignments(resolveOutput)

          env.TFVARS_PATH = requireValue(inputs, 'TFVARS_PATH')
          env.BACKEND_PATH = requireValue(inputs, 'BACKEND_PATH')

          echo "TFVARS file: ${env.TFVARS_PATH}"
          echo "Backend config: ${env.BACKEND_PATH}"
        }
      }
    }

    stage('Terraform Init') {
      steps {
        dir('terraform/jenkins') {
          script {
            terraformExec(['init', '-backend-config', env.BACKEND_PATH])
          }
        }
      }
    }

    stage('Config Plan') {
      steps {
        dir('terraform/jenkins') {
          script {
            terraformExec([
              'plan',
              '-input=false',
              '-var-file',
              env.TFVARS_PATH,
              '-target=module.jenkins_config'
            ])
          }
        }
      }
    }

    stage('Config Apply') {
      steps {
        dir('terraform/jenkins') {
          script {
            terraformExec([
              'apply',
              '-input=false',
              '-auto-approve',
              '-var-file',
              env.TFVARS_PATH,
              '-target=module.jenkins_config'
            ])
          }
        }
      }
    }
  }
}

def terraformExec(List<String> args) {
  if (!args || args.isEmpty()) {
    error 'terraformExec requires at least one argument'
  }

  String exports = [
    "PYTHON_CMD=${shellEscape(env.PYTHON_CMD ?: '')}",
    "FILTER_SCRIPT=${shellEscape(env.FILTER_SCRIPT ?: '')}",
    "FILTER_AVAILABLE=${shellEscape(env.FILTER_AVAILABLE ?: '0')}"
  ].join(' ')

  String scriptRoot = env.PIPELINE_SCRIPT_ROOT ?: (env.WORKSPACE ? "${env.WORKSPACE}/pipeline/script" : 'pipeline/script')
  String execScript = shellEscape("${scriptRoot}/terraform_exec.sh")
  String command = args.collect { shellEscape(it) }.join(' ')
  sh label: "terraform ${args[0]}", script: "${exports} ${execScript} ${command}".trim()
}

def parseAssignments(String text) {
  def result = [:]
  def lines = text ? text.split("\\r?\\n") : []
  lines.each { line ->
    def trimmed = line.trim()
    if (!trimmed) {
      return
    }
    int idx = trimmed.indexOf('=')
    if (idx > 0) {
      String key = trimmed.substring(0, idx)
      String value = trimmed.substring(idx + 1)
      result[key] = value
    }
  }
  return result
}

def requireValue(Map data, String key) {
  if (!data.containsKey(key)) {
    error "Helper script did not provide ${key}"
  }
  def value = data[key]
  if (value == null || value.trim().isEmpty()) {
    error "Helper script returned empty ${key}"
  }
  return value
}

def shellEscape(String value) {
  if (value == null || value.isEmpty()) {
    return "''"
  }
  return "'" + value.replace("'", "'\\''") + "'"
}
